Платформа Veda. Постулаты авторизации и всего такого.

I) Об организационной структуре.
	1) В организации может быть любое количество параллельных организационных структур.
	2) Все организационные структуры равнозначны.
	3) Каждая организационная структура является древовидной и содержит должности (Position) в качестве листьев.
	4) Отнесение реальных людей (Person) к организационной структуре осуществляется при помощи объектов типа Назначение (Appointment).
	5) Роли в бизнес-процессах = Должности (Position).

II) Контрольные вопросы / ответы.
1) В: Кто указывается автором всех создаваемых индивидов?
   О: Текущее назначение пользователя.

2) В: Кого выбирать в полях типа работник?
   О: Ответ: Экземпляр класса Appointment.

3) В: Кого выбирать в полях типа человек?
   О: Ответ: Экземпляр класса Person.

4) В: Кого выбирать в полях типа должность?
   О: Ответ: Экземпляр класса Position.

5) В: Кого выбирать получателем при выдаче задачи?
   О: Ответ: Экземпляр класса Position.

6) В: Как передать права на задачи при смене должности?
   О: Ответ: Создать в системе новое назначение (Appointment) человека на эту должность.

7) В: Как проводить авторизацию, по отношению к кому?
   О: Согласно алгоритму авторизации.

8) В: Как визуализировать выбор получателя задачи?
   О: При выборе получателя задачи пользователю предлагается выбор из всех назначений. 
      При выборе конкретного назначения получателем указывается должность из этого назначения.

9) В: Как разбирать задачи из ролевых ящиков?
    О: Перенаправлять в ящик своей должности.

10) В: Как получить права на задачи другой должности?
    О: Создать временное назначение на эту должность. При завершении назначения человек должен терять права на задачи.

III) Алгоритмы авторизации.

1. Включение реальных людей в группы должностей (на сервере).
С1. При сохранении индивида класса Appointment запускается обработчик.
С2. Создается индивид класса принадлежность (Membership).
С3. Значением предиката v-s:resource устанавливается значение предиката v-s:employee из назначения.
С4.	Значением предиката v-s:memberOf устанавливается значение предиката v-s:occupation из назначения.
С5.	Выполняется команда put_individual для принадлежности.
С6.	Выполнение обработчика завершается.

2. Назначение прав автору нового индивида.
На стороне клиента:
К1. При создании нового индивида, клиентское приложение дополняет индивид предикатами v-s:author, v-s:created. 
К2. Значением предиката v-s:author устанавливается текущее (выбранное) назначение пользователя.
К3. Значением предиката v-s:created устанавливается текущий момент времени.
К4. В момент выполнения команды сохранения индивида, клиент выполняет команду put_individual.

На стороне сервера (server js script):
С1. При выполнении команды (put_individual) запускается обработчик.
С2. Считывается предыдущее состояние записываемого индивида. 
С3. Если предыдущего состояния не существует, то индивид считается новым, и для него необходимо установить права доступа.
    В противном случае сравниваются значения предикатов v-s:author старого и нового состояния индивида.
		Если значения совпадают, обработчик прекращает свою работу (права уже выданы ранее).
		Если значения различаются, индивид приводится к старому состоянию, выполняется команда put_individual (не даем подменить автора существующего объекта).
С4. Информация об авторе индивида извлекается из предиката v-s:author.
C5. Выполняется проверка соответствия пользователя от имени которого идет операция записи и назначения, указанном в предикате v-s:author. 
    (Это необходимо для того, чтобы нельзя было подделать авторство индивида.)
    При выполнении проверки, uri пользователя (Person), вычисляемый из тикета, сравнивается со значением предиката v-s:employee, указанном в назначении.
		Если значения различаются, в индивид вписывается предикат v-s:deleted со значением true, выполнение обработчика завершается (права не назначаются, индивид никому не будет доступен).
		Если значения совпадают, создается запись авторизации (PermissionStatement).
			Значение предиката v-s:subject устанавливается равным значению v-s:occupation из назначения (должность).
			Значение предиката v-s:object устанавливается равным uri создаваемого субъекта.
			Значение предиката v-s:canCreate, v-s:canRead, v-s:canUpdate, v-s:canDelete устанавливается равным true.
			Выполняется команда put_individual для записи авторизации.
			Выполнение обработчика завершается.

3. Авторизация доступа к индивиду.
При выполнении проверки прав доступа (на сервере).
С1. По тикету вычисляется пользователь.
С2. Производится поиск всех групп, в которых состоит пользователь.
С3. Производится поиск всех групп, в которых состоит запрашиваемый ресурс.
С4. Производится поиск подходящих записей авторизации, в которых есть группа пользователя и группа ресурса.


========================================================

Вычисление прав доступа субъекта по отношению к объекту.

Введем 2 служебные базы данных:
1) База данных субъектов типа Membership.
2) База данных субъектов типа PermissionStatement.

Структура записи membership:
{ 
	uri: subject_uri,
	subject: subject_uri,
	memberOf: 
	[{ 
		uri: group_uri, right: 1 | 2 | ... | 15
	}]
}
* Ключ membership совпадает с ключом ресурса.
* Вес вхождения в группу по-умолчанию равен 15.

Структура записи permissionStatement:
{ 
	uri: object_uri,
	object: object_uri,
	subject:
	[{ 
		uri: group_uri, right: 1 | 2 | ... | 15
	}]
}
* Ключ permissionStatement совпадает с ключом ресурса.

Для оптимизации количества обращений к базе данных используем вытесняющий кэш.

При вычислении права доступа:

1) Получаем цепочки всех групп объекта доступа.
При этом, если в цепочке принадлежностей был указан уровень прав, этим же уровнем помечаются все группы далее по цепочке.
Поскольку уровень прав одних и тех же групп в разных цепочках иерархии может отличаться, формируем общий список групп объекта с указанием для каждой группы всех уровней прав.

Пример:
[
	{
		uri: group_uri1,
		right: [3, 15]
	},
	{
		uri: group_uri2,
		right: [3, 5]
	},
]

2) Получаем цепочки всех групп субъекта доступа (пользователя). Формируем общий список групп в которые входит субъект (пользователь). Иерархия не важна.
Пример:
[ user_group_uri1, user_group_uri, ...]

3) Для каждой группы из списка групп объекта доступа извлекаем permissionStatement и проверяем есть ли совпадения из списка групп (поле subject) со списком групп пользователя.

4) При наличии совпадения группы ресурса и субъекта производим операцию побитового "И" уровня прав из permissionStatement и списком прав доступа из пункта 1). 
Выбираем большее значение плученного права.

* После некоторого времени за счет использования вытесняющего кэша, количество обращений к базе данных резко сократится.





















