Платформа Veda. Постулаты авторизации и всего такого.

I) Об организационной структуре.
	1) В организации может быть любое количество параллельных организационных структур.
	2) Все организационные структуры равнозначны.
	3) Каждая организационная структура является древовидной и содержит должности (Position) в качестве листьев.
	4) Отнесение реальных людей (Person) к организационной структуре осуществляется при помощи объектов типа Назначение (Appointment).
	5) Роли в бизнес-процессах = Должности (Position).

II) Контрольные вопросы / ответы.
1) В: Кто указывается автором всех создаваемых индивидов?
   О: Текущее назначение пользователя.

2) В: Кого выбирать в полях типа работник?
   О: Ответ: Экземпляр класса Appointment.

3) В: Кого выбирать в полях типа человек?
   О: Ответ: Экземпляр класса Person.

4) В: Кого выбирать в полях типа должность?
   О: Ответ: Экземпляр класса Position.

5) В: Кого выбирать получателем при выдаче задачи?
   О: Ответ: Экземпляр класса Position.

6) В: Как передать права на задачи при смене должности?
   О: Ответ: Создать в системе новое назначение (Appointment) человека на эту должность.

7) В: Как проводить авторизацию, по отношению к кому?
   О: Согласно алгоритму авторизации.

8) В: Как визуализировать выбор получателя задачи?
   О: При выборе получателя задачи пользователю предлагается выбор из всех назначений. 
      При выборе конкретного назначения получателем указывается должность из этого назначения.

9) В: Как разбирать задачи из ролевых ящиков?
    О: Перенаправлять в ящик своей должности.

10) В: Как получить права на задачи другой должности?
    О: Создать временное назначение на эту должность. При завершении назначения человек должен терять права на задачи.

III) Алгоритмы авторизации.

1. Включение реальных людей в группы должностей (на сервере).
С1. При сохранении индивида класса Appointment запускается обработчик.
С2. Создается индивид класса принадлежность (Membership).
С3. Значением предиката v-s:resource устанавливается значение предиката v-s:employee из назначения.
С4.	Значением предиката v-s:memberOf устанавливается значение предиката v-s:occupation из назначения.
С5.	Выполняется команда put_individual для принадлежности.
С6.	Выполнение обработчика завершается.

2. Назначение прав автору нового индивида.
На стороне клиента:
К1. При создании нового индивида, клиентское приложение дополняет индивид предикатами v-s:author, v-s:created. 
К2. Значением предиката v-s:author устанавливается текущее (выбранное) назначение пользователя.
К3. Значением предиката v-s:created устанавливается текущий момент времени.
К4. В момент выполнения команды сохранения индивида, клиент выполняет команду put_individual.

На стороне сервера (server js script):
С1. При выполнении команды (put_individual) запускается обработчик.
С2. Считывается предыдущее состояние записываемого индивида. 
С3. Если предыдущего состояния не существует, то индивид считается новым, и для него необходимо установить права доступа.
    В противном случае сравниваются значения предикатов v-s:author старого и нового состояния индивида.
		Если значения совпадают, обработчик прекращает свою работу (права уже выданы ранее).
		Если значения различаются, индивид приводится к старому состоянию, выполняется команда put_individual (не даем подменить автора существующего объекта).
С4. Информация об авторе индивида извлекается из предиката v-s:author.
C5. Выполняется проверка соответствия пользователя от имени которого идет операция записи и назначения, указанном в предикате v-s:author. 
    (Это необходимо для того, чтобы нельзя было подделать авторство индивида.)
    При выполнении проверки, uri пользователя (Person), вычисляемый из тикета, сравнивается со значением предиката v-s:employee, указанном в назначении.
		Если значения различаются, в индивид вписывается предикат v-s:deleted со значением true, выполнение обработчика завершается (права не назначаются, индивид никому не будет доступен).
		Если значения совпадают, создается запись авторизации (PermissionStatement).
			Значение предиката v-s:subject устанавливается равным значению v-s:occupation из назначения (должность).
			Значение предиката v-s:object устанавливается равным uri создаваемого субъекта.
			Значение предиката v-s:canCreate, v-s:canRead, v-s:canUpdate, v-s:canDelete устанавливается равным true.
			Выполняется команда put_individual для записи авторизации.
			Выполнение обработчика завершается.

3. Авторизация доступа к индивиду.
При выполнении проверки прав доступа (на сервере).
С1. По тикету вычисляется пользователь.
С2. Производится поиск всех групп, в которых состоит пользователь.
С3. Производится поиск всех групп, в которых состоит запрашиваемый ресурс.
С4. Производится поиск подходящих записей авторизации, в которых есть группа пользователя и группа ресурса.


========================================================

Вычисление прав доступа субъекта по отношению к объекту.

Введем 2 области хранения данных:
1) Данные субъектов типа Membership.
2) Данные субъектов типа PermissionStatement.

===============

* Ключ membership совпадает с ключом ресурса.

Пример записи membership:
object_uri_m : { 
	object_group_uri1 : CR,
	object_group_uri2 : CR,
	object_group_uri3 : CRUD
}

* Уровень прав вхождения в группу по-умолчанию равен CRUD.

===============

* Ключ permissionStatement совпадает с ключом ресурса (документа).

Пример записи permissionStatement:
object_uri_p : {
	subject_group_uri1 : CR, 
	subject_group_uri2 : CR, 
	subject_group_uri3 : CRUD 
}

===============

Алгоритм вычисления права доступа:

переменные: 
	object - объект доступа
	subject - субъект доступа

1) Получаем цепочки всех групп объекта, запрашивая объекты типа membership по сформированному uri:  object_uri + "_m".
При этом, если в цепочке принадлежностей был указан уровень прав, этим же уровнем помечаются все группы далее по цепочке.
Поскольку уровень прав одних и тех же групп в разных цепочках иерархии может отличаться, формируем общий хэш групп объекта с указанием для каждой группы всех уровней прав из разных цепочек.

Пример:
object_groups = {
	// включаем сам объект
	object_uri: [CRUD], 
	object_group_uri1: [ CR, CRUD ], 
	object_group_uri2: [ CR ], 
	object_group_uri3: [ CR ], 
}

2) Получаем цепочки всех групп субъекта (пользователя). Формируем общий список групп в которые входит субъект (персона). Иерархия не важна.

Пример:
subject_groups = [
	// включаем сам субъект
	subject_uri,
	subject_group_uri1, 
	subject_group_uri2, 
	subject_group_uri3 
]

3) Для каждого ключа хэша k1 из objects_groups извлекаем permissionStatement по сформированному uri:  object_uri + "_p".

Пример:
object_uri_p : {
	subject_group_uri3 : CRUD
}

Для каждого элемента subject_groups проверяем, есть ли такой ключ в хэше permissionStatement (k2).
При наличии ключа выполняем операцию побитового "И" каждого значения из списка object_groups[k1] со значением permissionStatement[k2].
Итоговым значением уровня прав считаем большее из полученных значений.

* Для оптимизации количества обращений к базе данных используем вытесняющий кэш (с учетом частоты запроса конкретного элемента!) для записей membership и permissionStatement.
* После некоторого времени за счет использования вытесняющего кэша, количество обращений к базе данных резко сократится поскольку в него войдут группы объектов высокого уровня и их разрешения (например, классы и группы орг. структуры).
