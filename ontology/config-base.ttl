@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix v-wf: <http://semantic-machines.com/veda/veda-workflow/> .
@prefix v-s: <http://semantic-machines.com/veda/veda-schema/> .
@prefix v-ui: <http://semantic-machines.com/veda/veda-ui/> .
@prefix v-l: <http://semantic-machines.com/veda/veda-layout/> .
@prefix m-l: <http://semantic-machines.com/veda/mondi-layout/> .
@prefix cfg: <http://semantic-machines.com/veda/config/> .
@prefix td: <http://semantic-machines.com/veda/test-data/> .

@prefix cfgb: <http://semantic-machines.com/veda/config-base/> .
<http://semantic-machines.com/veda/config-base>
  rdf:type owl:Ontology ;
  rdfs:label "Veda system administrator ontology"@en ;
  rdfs:label "Онтология администратора системы Веда"@ru ;
#  owl:versionInfo "1.0" ;
  v-s:loadPriority 2 ;
.

cfg:Guest
  rdf:type v-s:Person ;
  v-s:author cfg:VedaSystem ;  
  v-s:firstName "Guest"@en ;
  v-s:firstName "Гость"@ru ;
  v-s:hasAccount cfg:GuestAccount ;
  rdfs:label "Guest"@en ;
  rdfs:label "Гость"@ru ;
.

cfg:GuestAccount
  rdf:type v-s:Account ;
  rdfs:label "Guest account"@en ;
  rdfs:label "Гостевая учетная запись"@ru ;
.

cfg:VedaSystem
  rdf:type v-s:Person ;
  v-s:author cfg:VedaSystem ;  
  v-s:actualVersion cfg:VedaSystem ;
  v-s:birthday "2014-03-05"^^xsd:dateTime ;
  v-s:firstName "Veda"@en ;
  v-s:firstName "Веда"@ru ;
  v-s:hasAccount cfg:VedaSystemAccount ;
  v-s:lastName "System"@en ;
  v-s:lastName "Система"@ru ;
  rdfs:label "Veda System"@en ;
  rdfs:label "Система Веда"@ru ;
.

cfg:VedaSystemAccount
  rdf:type v-s:Account ;
  v-s:author cfg:VedaSystem ;
  v-s:login "veda" ;
  v-s:password "4d1af0e10dab5fe07ae8d23bad5650b46804fb110cfb92f119213bc86aa03d34" ;
  v-s:owner cfg:VedaSystem ;
  rdfs:label "Veda System account"@en ;
  rdfs:label "Учетная запись системы Веда"@ru ;
.

cfg:SuperAdmin
  rdf:type v-s:Group ;
  v-s:author cfg:VedaSystem ;  
  rdfs:label "Super admin"@en ;
  rdfs:label "Супер админ"@ru ;
.

cfg:TTLResourcesGroup
  rdf:type v-s:Group ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "TTL resources group"@en ;
  rdfs:label "Группа всех ресурсов из TTL"@ru ;
.

cfg:AllUsersGroup
  rdf:type v-s:Group ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "All users group"@en ;
  rdfs:label "Группа всех пользователей"@ru ;
.

cfg:OntologyGroup
  rdf:type v-s:Group ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "Group for Ontology individuals"@en ;
  rdfs:label "Группа для индивидов онтологии"@ru ;
.

cfg:Membership_1
  rdf:type v-s:Membership ;
  v-s:author cfg:VedaSystem ;
  v-s:resource cfg:VedaSystem ;
  v-s:memberOf cfg:SuperAdmin ;
.

cfg:Permission_1
  rdf:type v-s:PermissionStatement ;
  v-s:author cfg:VedaSystem ;  
  v-s:permissionSubject cfg:SuperAdmin ;
  v-s:permissionObject v-s:AllResourcesGroup ;
  v-s:canCreate "true"^^xsd:boolean ;
  v-s:canDelete "true"^^xsd:boolean ;
  v-s:canRead "true"^^xsd:boolean ;
  v-s:canUpdate "true"^^xsd:boolean ;
.

cfg:Permission_2
  rdf:type v-s:PermissionStatement ;
  v-s:author cfg:VedaSystem ;
  v-s:permissionSubject cfg:AllUsersGroup ;
  v-s:permissionObject cfg:TTLResourcesGroup ;
  v-s:canRead "true"^^xsd:boolean ;
  rdfs:label "Permissions to read TTL resources for all users"@en ;
  rdfs:label "Право на чтение всех ресурсов из TTL для всех пользователей"@ru ;
.

cfg:Permission_3
  rdf:type v-s:PermissionStatement ;
  v-s:author cfg:VedaSystem ;
  v-s:permissionSubject cfg:AllUsersGroup ;
  v-s:permissionObject cfg:OntologyGroup ;
  v-s:canRead "true"^^xsd:boolean ;
  rdfs:label "Permission to read ontology individuals for all users"@en ;
  rdfs:label "Разрешение на чтение онтологии для всех пользователей"@ru ;
.

cfg:Permission_4
  rdf:type v-s:PermissionStatement ;
  v-s:author cfg:VedaSystem ;
  v-s:permissionSubject cfg:AllUsersGroup ;
  v-s:permissionObject v-s:OrganizationUnit ;
  v-s:canRead "true"^^xsd:boolean ;
  rdfs:label "Permission to read org. structure individuals for all users"@en ;
  rdfs:label "Разрешение на чтение орг. структуры для всех пользователей"@ru ;
.

##################### EVENT HANDLERS #####################


cfg:Event_1
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "Скрипт помещает все индивиды в группу cfg:TTLResourcesGroup";
  rdfs:comment "Скрипт помещает все индивиды в группу cfg:TTLResourcesGroup";
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = user whose actions triggered event
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 */
var doc_uri = document['@'],
	isDefinedBy = document['rdfs:isDefinedBy'];
if ( !isDefinedBy ) return;
var uri = 'd:membership_' + doc_uri.split(':').join('_') + '_' + 'cfg_TTLResourcesGroup',
	membership = {
		'@' : uri, 
		'rdf:type'     : newUri('v-s:Membership'),
		'v-s:memberOf' : newUri('cfg:TTLResourcesGroup'),
		'v-s:resource' : newUri(doc_uri),
		'rdfs:comment' : newStr('создано автоматически в обработчике cfg:Event_1')
	};
put_individual(ticket, membership, _event_id);

// print('cfg:Event_1', uri);

  """ ;
.

cfg:Event_2
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "Скрипт выдает права авторам (v-s:author) и владельцам (v-s:owner)";
  rdfs:comment "Скрипт выдает права авторам (v-s:author) и владельцам (v-s:owner)";
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = user whose actions triggered event
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 */

var doc_uri = document['@'],
	vs_owner = document['v-s:owner'];

if (vs_owner) {
	addRight(ticket, [can_read, can_update, can_delete], getUri(vs_owner), doc_uri);
}

var vs_author = document["v-s:author"];
if (vs_author) {
    var author = get_individual(ticket, getUri(vs_author));
    if (author) {
		
		var author_type = getUri(author['rdf:type']);
		
		if (author_type == 'v-s:Person') {
			addRight(ticket, [can_read, can_update, can_delete], getUri(vs_author), doc_uri); 
		} else {
			var ff = get_property_chain (ticket, document, 'v-s:author', 'v-s:occupation');
			if (ff) {
				var position_uri = getUri (ff['field']);
				var first_doc = ff['first'];
				if (first_doc) {
					doc_uri = first_doc['@'];	
					if (position_uri) {
						addRight(ticket, [can_read, can_update, can_delete], position_uri, doc_uri);
					}
				}
			}
		}
    }
}
  """ ;
.

cfg:Event_3
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "Скрипт создает журнал документа" ;
  rdfs:comment "Скрипт создает журнал документа" ;
  v-s:filter v-s:Journaling ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = user whose actions triggered event
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 */

// No journaling for technical changes 
// No journaling for draft
if (!(document['v-s:isDraftOf'] && document['v-s:isDraftOf'].length > 0 || (document['v-s:hasDraft'] && document['v-s:hasDraft'].length > 0)) && !isTecnicalChange(document, prev_state))
{
    var author_uri = getUri(document['v-s:author']);
    if (!author_uri) { return; }

    var author = get_individual(ticket, author_uri);
    if (!author) { return; }

    var employee_uri;
    if (isExists(author['rdf:type'], newUri('v-s:Appointment')))
    {
        employee_uri = author['v-s:employee'];
        if (!employee_uri) { return; }
    }
    else
    {
        employee_uri = author_uri;
    }

    if (!employee_uri) { return; }

    var journal_uri = getJournalUri(document['@']);
    var exist_journal = get_individual(ticket, journal_uri);
    if (exist_journal)
    {
        // UPDATE DOCUMENT
        var journal_record = newJournalRecord(journal_uri);
        if (document['v-s:actualVersion'] && document['v-s:actualVersion'][0].data == document['@'])
        {
            journal_record['v-s:documentVersion'] = document['v-s:previousVersion'];
        }

        if ((!prev_state['v-s:deleted'] || prev_state['v-s:deleted'].data == 'false') &&
            (document['v-s:deleted'] && document['v-s:deleted'].data == 'true'))
        {
            journal_record['rdf:type'] = [
            {
                data: 'v-s:DocumentDeleted',
                type: _Uri
            }];
        }
        else
        {
            journal_record['rdf:type'] = [
            {
                data: 'v-s:DocumentUpdated',
                type: _Uri
            }];
        }

        journal_record['v-s:actor'] = [
        {
            data: user_uri,
            type: _Uri
        }];

        logToJournal(ticket, journal_uri, journal_record);
        addRight(ticket, [can_read], 'cfg:AllUsersGroup', journal_record['@']);
    }
    else
    {
        // CREATE DOCUMENT		
        var new_journal = {
            '@': journal_uri,
            'rdf:type': [
            {
                data: 'v-s:Journal',
                type: _Uri
            }],
            'v-s:onDocument': [
            {
                data: document['@'],
                type: _Uri
            }],
            'v-s:actor': [
            {
                data: user_uri,
                type: _Uri
            }]
        };
        put_individual(ticket, new_journal, _event_id);
        addRight(ticket, [can_read], 'cfg:AllUsersGroup', journal_uri);

        var journal_record = newJournalRecord(new_journal);
        if (document['v-s:actualVersion'] && document['v-s:actualVersion'][0].data == document['@'])
        {
            journal_record['v-s:documentVersion'] = document['v-s:previousVersion'];
        }
        journal_record['rdf:type'] = [
        {
            data: 'v-s:DocumentCreated',
            type: _Uri
        }];
        journal_record['v-s:actor'] = [
        {
            data: user_uri,
            type: _Uri
        }];
        logToJournal(ticket, journal_uri, journal_record);
        addRight(ticket, [can_read], 'cfg:AllUsersGroup', journal_record['@']);
    }
}
  """ ;
.

cfg:Event_4
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "Скрипт включает единицу орг. структуры в группу родительской единицы. Включает персону в группу должности." ;
  rdfs:comment "Скрипт включает единицу орг. структуры в группу родительской единицы. Включает персону в группу должности." ;
  v-s:filter v-s:Organization ;
  v-s:filter v-s:Department ;
  v-s:filter v-s:Position ;
  v-s:filter v-s:Appointment ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = user whose actions triggered event
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 */

var doc_uri = document['@'],
	deleted = hasValue(document, "v-s:deleted", { data: true, type: _Boolean });

if ( hasValue(document, "v-s:parentUnit") ) {
	var parents = getUris( document["v-s:parentUnit"] );
	parents.map(function (parent_uri) {
		var uri = "d:membership_" + doc_uri.split(":").join("_") + "_" + parent_uri.split(":").join("_"),
			membership = {
				'@' : uri, 
				'rdf:type'     : newUri("v-s:Membership"),
				'v-s:resource' : newUri(doc_uri),
				'v-s:memberOf' : newUri(parent_uri),
				'rdfs:comment' : newStr("выдан cfg:Event_4")
			};
		if (deleted) {
			membership['v-s:deleted'] = newBool(true);
		}
		put_individual (ticket, membership, _event_id);
		
		//print('cfg:Event_4 (unit to parent)', uri);
		
	});
}

if ( hasValue(document, "rdf:type", { data: "v-s:Appointment", type: _Uri }) ) {
	var person_uri = getUri(document['v-s:employee']),
		position_uri = getUri(document['v-s:occupation']);

	if (!person_uri || !position_uri) return;

	var uri = 'd:membership_' + person_uri.split(':').join('_') + '_' + position_uri.split(':').join('_'),
		membership = {
			'@' : uri, 
			'rdf:type'     : newUri('v-s:Membership'),
			'v-s:memberOf' : newUri(position_uri),
			'v-s:resource' : newUri(person_uri),
			'rdfs:comment' : newStr('создано автоматически в обработчике cfg:Event_4')
		};
	if (deleted) {
		membership['v-s:deleted'] = newBool(true);
	}
	put_individual (ticket, membership, _event_id);
	
	//print('cfg:Event_4 (unit to position)', uri);
	
}
  """ ;
.

cfg:Event_5
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "Скрипт включает персону (кроме cfg:Guest) в группу cfg:AllUsersGroup." ;
  rdfs:comment "Скрипт включает персону (кроме cfg:Guest) в группу cfg:AllUsersGroup." ;
  v-s:filter v-s:Person ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = user whose actions triggered event
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 */

var doc_uri = document['@'],
	deleted = hasValue(document, 'v-s:deleted', { data: true, type: _Boolean}),
	uri = 'd:membership_' + doc_uri.split(':').join('_') + '_' + 'cfg_AllUsersGroup';

if (doc_uri === 'cfg:Guest') { return; }
    
var membership = {
	'@' : uri, 
	'rdf:type'     : newUri('v-s:Membership'),
	'v-s:resource' : newUri(doc_uri),
	'v-s:memberOf' : newUri('cfg:AllUsersGroup'),
	'rdfs:comment' : newStr('выдан cfg:Event_5')
};
if (deleted) {
	membership['v-s:deleted'] = newBool(true);
}
put_individual (ticket, membership, _event_id);

//print('cfg:Event_5', uri);

  """ ;
.

cfg:Event_6
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "Скрипт включает индивид онтологии и UI настроек в группу cfg:OntologyGroup." ;
  rdfs:comment "Скрипт включает индивид онтологии и UI настроек в группу cfg:OntologyGroup." ;
  v-s:filter rdf:Property ;
  v-s:filter rdfs:Class ;
  v-s:filter rdfs:Datatype ;
  v-s:filter owl:Class ;
  v-s:filter owl:Ontology ;
  v-s:filter owl:DatatypeProperty ;
  v-s:filter owl:ObjectProperty ;
  v-s:filter owl:Restriction ;
  v-s:filter v-s:ClassModel ;
  v-s:filter v-ui:ClassTemplate ;
  v-s:filter v-ui:PropertySpecification ;
  v-s:filter v-ui:IntegerPropertySpecification ;
  v-s:filter v-ui:DecimalPropertySpecification ;
  v-s:filter v-ui:DatetimePropertySpecification ;
  v-s:filter v-ui:StringPropertySpecification ;
  v-s:filter v-ui:BooleanPropertySpecification ;
  v-s:filter v-ui:ObjectPropertySpecification ;
  v-s:filter v-s:Bundle ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = user whose actions triggered event
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 */

// Update ontology vsn
var vsn = {
	"@" : "cfg:OntoVsn", 
	"rdf:type"  : newUri("rdfs:Resource"),
	"rdf:value" : newStr( guid() )
};
put_individual (ticket, vsn, _event_id);

// Add to cfg:OntologyGroup
var doc_uri = document['@'],
	uri = "d:membership_" + doc_uri.split(":").join("_") + "_" + "cfg_OntologyGroup",
	membership = get_individual(ticket, uri);

if (membership) { return; }

membership = {
	'@' : uri, 
	'rdf:type'     : newUri('v-s:Membership'),
	'v-s:memberOf' : newUri('cfg:OntologyGroup'),
	'v-s:resource' : newUri(doc_uri),
	'rdfs:comment' : newStr('выдан cfg:Event_6')
};
put_individual (ticket, membership, _event_id);

//print('cfg:Event_6', uri);
  """ ;
.

cfg:Event_7
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "Скрипт включает индивид в группу своего класса." ;
  rdfs:comment "Скрипт включает индивид в группу своего класса." ;
  v-s:filter v-s:Authorized ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = user whose actions triggered event
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 */

if (parent_document_id && parent_document_id === document['@']) return;

var doc_uri = document["@"],
	_classes = getUris( document["rdf:type"] ),
	doc_deleted = hasValue(document, "v-s:deleted", { data: true, type: _Boolean});

_classes.map(function (class_uri) {
	if (
		class_uri === "owl:Thing" 
		|| class_uri === "rdfs:Resource" 
		|| class_uri === "v-s:Membership" 
		|| class_uri === "v-s:PermissionStatement"
	) {
		return;
	}
	var uri = 'd:membership_' + doc_uri.split(':').join('_') + '_' + class_uri.split(':').join('_'),
		membership = get_individual(ticket, uri);
	
	if (!membership) {
		membership = {
			'@' : uri, 
			'rdf:type'     : newUri('v-s:Membership'),
			'v-s:memberOf' : newUri(class_uri),
			'v-s:resource' : newUri(doc_uri),
			'rdfs:comment' : newStr('создано cfg:Event_7')
		};
		if (doc_deleted) {
			membership['v-s:deleted'] = newBool(true);
		}
	} else {
		var mem_deleted = hasValue(membership, "v-s:deleted", { data: true, type: _Boolean});
		if ( doc_deleted && !mem_deleted ) {
			membership["v-s:deleted"] = newBool(true);
		} else if ( !doc_deleted && mem_deleted ) {
			delete membership['v-s:deleted'];
		} else {
			return ;
		}
	}
	put_individual (ticket, membership, _event_id);	
	
	//print('cfg:Event_7', uri);
	
});
  """ ;
.

cfg:Event_8
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "Скрипт включает класс в группу своего суперкласса." ;
  rdfs:comment "Скрипт включает класс в группу своего суперкласса." ;
  v-s:filter rdfs:Class ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = user whose actions triggered event
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 */

if (parent_document_id && parent_document_id === document['@']) return;

var _class = document,
	class_uri = _class["@"],
	class_deleted = hasValue(_class, "v-s:deleted", { data: true, type: _Boolean});

if ( !hasValue(_class, "rdfs:subClassOf") ) { return; }

var _super_classes = getUris( _class["rdfs:subClassOf"] );

_super_classes.map(function (super_uri) {
	if ( super_uri === "owl:Thing" || class_uri === "rdfs:Resource" ) {
		return;
	}
	var uri = 'd:membership_' + class_uri.split(':').join('_') + '_' + super_uri.split(':').join('_'),
		membership = get_individual(ticket, uri);
	
	if (!membership) {
		membership = {
			'@' : uri, 
			'rdf:type'     : newUri('v-s:Membership'),
			'v-s:memberOf' : newUri(super_uri),
			'v-s:resource' : newUri(class_uri),
			'rdfs:comment' : newStr('создано cfg:Event_8')
		};
		if (class_deleted) {
			membership['v-s:deleted'] = newBool(true);
		}
	} else {
		var mem_deleted = hasValue(membership, "v-s:deleted", { data: true, type: _Boolean});
		
		if ( class_deleted && !mem_deleted ) {
			membership["v-s:deleted"] = newBool(true);
		} else if ( !class_deleted && mem_deleted ) {
			delete membership['v-s:deleted'];
		} else {
			return ;
		}
	}
	put_individual (ticket, membership, _event_id);
	
	//print('cfg:Event_8', uri);
	
});
  """ ;
.

cfg:Event_9
  rdf:type v-s:Event ;
  v-s:author cfg:VedaSystem ;
  rdfs:label "Скрипт включает вложенные индивиды в группу своего родителя." ;
  rdfs:comment "Скрипт включает вложенные индивиды в группу своего родителя." ;
  v-s:filter v-s:Embedded ;
  v-s:script """
/* Available variables:
 * ticket = superuser ticket
 * document = captured document
 * user_uri = user whose actions triggered event
 * prev_state = user whose actions triggered event
 * _event_id = id of the event to prevent cycles in triggers. Must be passed to every function that modifies DB.
 * parent_script_id = id of the parent script that triggered this event.
 * parent_document_id = id of the document that triggered this event.
 */

var doc_uri = document["@"],
	parent_uri = getUri( document["v-s:parent"] ),
	doc_deleted = hasValue(document, "v-s:deleted", { data: true, type: _Boolean});

//print('cfg:Event_9', 'start', 'parent_uri', parent_uri );

if (!parent_uri) { return; }

var uri = 'd:membership_' + doc_uri.split(':').join('_') + '_' + parent_uri.split(':').join('_'),
	membership = get_individual(ticket, uri);

if (!membership) {
	membership = {
		'@' : uri, 
		'rdf:type'     : newUri('v-s:Membership'),
		'v-s:memberOf' : newUri(parent_uri),
		'v-s:resource' : newUri(doc_uri),
		'rdfs:comment' : newStr('создано cfg:Event_9')
	};
	if (doc_deleted) {
		membership['v-s:deleted'] = newBool(true);
	}
} else {
	var mem_deleted = hasValue(membership, "v-s:deleted", { data: true, type: _Boolean});
	if ( doc_deleted && !mem_deleted ) {
		membership["v-s:deleted"] = newBool(true);
	} else if ( !doc_deleted && mem_deleted ) {
		delete membership['v-s:deleted'];
	} else {
		//print('cfg:Event_9', uri, 'nothing changed');
		return ;
	}
}
put_individual (ticket, membership, _event_id);	

//print('cfg:Event_9', uri);
	
  """ ;
.
